#+STARTUP: indent
#+TITLE: A literate Emacs configuration
#+DESCRIPTION: This file contains my Emacs init.el configuration as a literate program, which is generated by tangling this document.
#+PROPERTY: header-args :tangle init.el :comments link :results none

* Basic setup for init
** Lexical binding
We set the heading line of the file, to enable lexical
binding. This makes it easier to define variables to use in hooks
that are run later, etc. See [[gc-thresholds][gc-threshold src block]] for example.

#+BEGIN_SRC emacs-lisp :comments none
  ;;; init.el --- Load the full configuration -*- lexical-binding: t -*-
#+END_SRC

** Enable debug if required
Produce backtraces when errors occur: can be helpful to diagnose startup issues
#+BEGIN_SRC emacs-lisp
  ;; (setq debug-on-error t)
#+END_SRC

** Check that Emacs is not too old
#+BEGIN_SRC emacs-lisp
  (let ((minver "25.1"))
    (when (version< emacs-version minver)
      (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

  (when (version< emacs-version "26.1")
    (message "Your Emacs is old, and some functionality in this config will be disabled. Please upgrade if possible."))
#+END_SRC

** Adjust garbage collection thresholds
Allow for a much higher garbage collection threshold during startup,
to prevent gc from slowing down startup.

#+name: gc-thresholds
#+BEGIN_SRC emacs-lisp
  (let ((normal-gc-cons-threshold (* 20 1024 1024))
        (init-gc-cons-threshold (* 128 1024 1024)))
    (setq gc-cons-threshold init-gc-cons-threshold)
    (add-hook 'emacs-startup-hook
              (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))
#+END_SRC

** ~init.el~ file generation
:PROPERTIES:
:CUSTOM_ID: my-make-init-el-function
:END:

We genarate the ~init.el~ file, whenever this file gets saved. We need
to save with a prefix argument, though. ~C-u C-x C-s~.

#+name: startup-code
#+BEGIN_SRC emacs-lisp
  (defun pc/tangle-init-el ()
    "Tangle the file to update init.el file."
    (interactive "P")
    (let* ((time (current-time))
           (org-babel-tangle-comment-format-beg "%source-name starts here"))
      (when current-prefix-arg
        ;; Make and load init.el
        (org-babel-tangle)
        ;; Acknowledgement
        (message
         "Tangled  init.el … %.06f seconds."
         (float-time (time-since time))))))

  (defun pc/load-init-el ()
    "Load the init.el file."
    (interactive)
    (let* ((time (current-time))
           (init-file (expand-file-name
                       "init.el"
                       (file-name-directory (buffer-file-name)))))

        ;; NOTE: Loading the init file doesn't work well...
        ;; We just tangle the file on save, and leave it at that. This
        ;; utility is left around, in case we occasionally chosee to
        ;; load the file manually. Ideally, when we are happy with the
        ;; config, we should just start a new Emacs instance.
        (setq pc/loading-tangled-init-p t)
        (load-file init-file)

        ;; Acknowledgement
        (message
         "Tangled, compiled, and loaded init.el … %.06f seconds. Restart Emacs if things get weird..."
         (float-time (time-since time)))))

  ;; Added this as a local variable in the org file
  ;; (add-hook 'after-save-hook 'org-babel-tangle nil 'local-to-this-file-please)
#+END_SRC
** Basic user information
#+begin_src emacs-lisp
  (setq user-full-name    "Puneeth Chaganti"
        user-mail-address "punchagan@muse-amuse.in")
#+end_src

For some fun, run this cute method.
#+BEGIN_SRC emacs-lisp :tangle no
  (animate-birthday-present user-full-name)
#+END_SRC
** System specific configuration
#+begin_src emacs-lisp
  (pcase (system-name)
    ("haalbai" (setq pc/code-directory "~/code/"))
    ("chandrahara" (setq pc/code-directory "~/software/")))
#+end_src
* Package manager and installation
** Setup ~package.el~
#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives '(("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.org/packages/")))

  ;; Update package list, unless previously updated. We do this only on the first
  ;; start-up. auth-update package takes care of it, for future startups
  (unless (file-exists-p (expand-file-name "elpa/archives/melpa" user-emacs-directory))
    (package-refresh-contents))

  ;; Ensure the installed packages are on load-path
  (package-initialize)
#+END_SRC
** Setup ~use-package~

The declarative configuration tool [[https://github.com/jwiegley/use-package/][use-package]] is a macro/interface
that manages our packages and the way they interact.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; ~use-package.el~ is no longer needed at runtime
  ;; Put the following at the top of your Emacs, to reduce load time:
  (eval-when-compile
    (require 'use-package))

  (use-package diminish)
  (use-package bind-key)
#+END_SRC

To make the setup bootstrap itself, we use let ~use-package~
automatically download missing requirements.

#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src
** Auto update package
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :config
    ;; Delete residual old versions
    (setq auto-package-update-delete-old-versions t)
    ;; Do not bother me when updates have taken place.
    (setq auto-package-update-hide-results t)
    ;; Update installed packages at startup if there is an update pending.
    (auto-package-update-maybe))
#+END_SRC
** System packages used from with-in Emacs

Sometimes Emacs packages depend on existing system binaries,
~use-package~ let's us ensure these exist using the
~:ensure-system-package~ keyword extension. This is a very powerful
system - see the documentation [[https://github.com/jwiegley/use-package#use-package-ensure-system-package][here]].

This is like ~:ensure t~ but operates at the OS level and uses your
default OS package manager. But, it can be customized to run specific
commands for update, etc.

We also run an auto-update for system packages, after an update for
Emacs packages is done ^_^.

#+BEGIN_SRC emacs-lisp
  ;; Auto installing OS system packages
  (use-package use-package-ensure-system-package
    :defer 4

    :config
    (setq system-packages-package-manager 'apt
          system-packages-use-sudo t
          system-packages-noconfirm t))

  ;; Please don't bother me when shell buffer names are in use, just make a new
  ;; buffer.
  (setq async-shell-command-buffer 'new-buffer)

  ;; Display the output buffer for asynchronous shell commands only when the
  ;; command generates output.
  (setq async-shell-command-display-buffer nil)

  ;; Don't ask me if I want to kill a buffer with a live process attached to it;
  ;; just kill it please.
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

* $PATH and such stuff
** Setup exec-path
To be able to find external programs, we want our ~exec-path~ to be as
close to ~$PATH~ as possible.

NOTE: When starting emacs from Gnome Shell, the env vars in
bash_profile are not in the env anyway? May be there's another trick,
or may be don't start emacs from Gnome Shell?

The block below is left here, because it seems to copy other useful
things like LANG, etc.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell

    :config
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
      (add-to-list 'exec-path-from-shell-variables var))

    (when (or (memq window-system '(mac ns x))
              (unless (memq system-type '(ms-dos windows-nt))
                (daemonp)))
      (exec-path-from-shell-initialize)))
#+END_SRC
** Use authinfo gpg file
#+BEGIN_SRC emacs-lisp
  (setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
** Start Emacs server
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

* Editor UI & Behavior
** Random Quote
Show a random quote when Emacs is idle for 5 minutes
#+BEGIN_SRC emacs-lisp
  (require 'json)

  (defun pc/get-random-quote ()
    (let* ((json-array-type 'list)
           (quotes-file (expand-file-name "quotes.json" user-emacs-directory))
           (quotes (and (file-exists-p quotes-file)
                        (json-read-file quotes-file)))
           (n (random (length quotes)))
           (q (nth n quotes))
           (text (cdr (assoc 'body q)))
           (source (cdr (assoc 'source q))))
      (format "%s — %s" text source)))

  (unless (boundp 'pc/quotes-timer)
    (setq pc/quotes-timer
          (run-with-idle-timer
           300
           'repeat-forever
           (lambda () (message (pc/get-random-quote))))))
#+END_SRC
** Lean UI
#+BEGIN_SRC emacs-lisp
  ;; No startup message
  (setq inhibit-startup-message t)

  (setq-default
   initial-scratch-message
   (format ";; Happy hacking, %s - Emacs ♥ you!\n\n" user-login-name))

  ;; No tool-bar, menu-bar and scroll-bar
  (tool-bar-mode   -1)
  (menu-bar-mode   -1)
  (scroll-bar-mode -1)

  ;; More prominent window divider
  (window-divider-mode 1)
#+END_SRC
** Basic Preferences

Miscellaneous basic preferences for basic editor actions (foreground &
background).

#+BEGIN_SRC emacs-lisp
  ;; Basic preferences (taken from purcell)
  (setq-default
   blink-cursor-interval 0.4
   bookmark-default-file (expand-file-name ".bookmarks.el" user-emacs-directory)
   buffers-menu-max-size 30
   case-fold-search t
   column-number-mode t
   confirm-kill-emacs (lambda (t) (y-or-n-p (format "%s\n%s" (pc/get-random-quote) t)))
   indent-tabs-mode nil
   create-lockfiles nil
   auto-save-default nil
   mouse-yank-at-point t
   save-interprogram-paste-before-kill t
   scroll-preserve-screen-position 'always
   set-mark-command-repeat-pop t
   tooltip-delay 1.5
   truncate-lines nil
   truncate-partial-width-windows nil)
#+END_SRC

Some more basic preferences which are called in the ~after-init-hook~.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'delete-selection-mode)

  (add-hook 'after-init-hook 'global-auto-revert-mode)
  (setq global-auto-revert-non-file-buffers t
        auto-revert-verbose nil)
  (with-eval-after-load 'autorevert
    (diminish 'auto-revert-mode))

  (add-hook 'after-init-hook 'transient-mark-mode)
#+END_SRC

Let's save a few precious seconds

#+begin_src emacs-lisp
;; change all prompts to y or n
(fset 'yes-or-no-p 'y-or-n-p)

;; Enable all ‘possibly confusing commands’ such as helpful but
;; initially-worrisome “narrow-to-region”, C-x n n.
(setq-default disabled-command-function nil)
#+end_src
*** Use UTF-8
#+begin_src emacs-lisp
  (set-default-coding-systems 'utf-8-unix)
#+end_src
** Fill column indicator
#+BEGIN_SRC emacs-lisp
  (when (boundp 'display-fill-column-indicator)
    (setq-default indicate-buffer-boundaries 'left)
    (setq-default display-fill-column-indicator-character ?│)
    (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode))
#+END_SRC

** ~diminish~ for modeline indicators

This should probably have automatically come as a dependency of
~use-package~, but doesn't seem to be. (It should at least warn about
missing package)

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :defer 3 ;; load after 5 seconds of idle time

    :config ;; Let's hide some markers.
    (diminish 'org-indent-mode))
#+END_SRC
** Use ~which-key~ for discovery
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config (which-key-mode)
    (which-key-setup-side-window-bottom)
    (setq which-key-idle-delay 0.5))
#+END_SRC
** Restore previous session
The following is disabled. I found it a nuisance to have my files open
across sessions. If I'm closing Emacs, it's for a good reason.

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Keep open files open across sessions.
  (desktop-save-mode 1)
  (setq desktop-restore-eager 10)
#+END_SRC
** Completion and Narrowing

See this [[https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html][blog post]] for more configuration options, and other packages
to install, etc.

Hit ~M-o~ to see the available actions in ivy/counsel completion
buffers! For instance, ~counsel-find-file~ allows copying, deleting or
renaming files!

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :diminish
    :ensure-system-package (ag . silversearcher-ag)
    :bind*                              ; load when pressed
    (("C-s"     . swiper)
     ("C-S-s" . counsel-ag)               ; Use ag to search the repo
     ("<f1> l"  . counsel-find-library)   ; find an Emacs Lisp library
     ("<f2> u"  . counsel-unicode-char))  ; insert a unicode symbol using a pop-up
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish
    :config
    ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; Number of lines to display
    (setq ivy-height 10)
    (setq ivy-count-format "[%d/%d] ")
    ;; no initial regexp by default (see original value using
    ;; `describe-variable')
    (setq ivy-initial-inputs-alist nil)
    (ivy-mode 1)
    (counsel-mode 1))
#+END_SRC

~swiper~ is an alternative to Emacs' default incremental search.
** Themes

#+BEGIN_SRC emacs-lisp
  ;; Don't prompt to confirm theme safety. This avoids problems with
  ;; first-time startup on Emacs > 26.3.
  (setq custom-safe-themes t)
#+END_SRC
*** Some code to pick and load a theme

#+BEGIN_SRC emacs-lisp
  (defun pc/load-theme (theme)
    "Apply user theme."
    (interactive
     (list
      (intern (ivy-read "Load custom theme: "
                        (mapcar #'symbol-name
                                (custom-available-themes))))))
    (progn
      ;; Disable all previously enabled themes
      (mapc 'disable-theme custom-enabled-themes)
      ;; Load chosen theme
      (load-theme theme)))
#+END_SRC

*** Ensure some nice themes are available
#+BEGIN_SRC emacs-lisp
  (use-package base16-theme)
  (unless (boundp 'pc/loading-tangled-init-p)
    (pc/load-theme 'base16-humanoid-dark))
#+END_SRC
** Symbol overlays
#+BEGIN_SRC emacs-lisp
  (use-package symbol-overlay
    :defer t
    :diminish t
    :hook
    (prog-mode . symbol-overlay-mode)
    (html-mode . symbol-overlay-mode)
    (yaml-mode . symbol-overlay-mode)
    (conf-mode . symbol-overlay-mode)
    :bind (:map symbol-overlay-mode-map
                ("M-i" . symbol-overlay-put)
                ("M-I" . symbol-overlay-remove-all)
                ("M-n" . symbol-overlay-jump-next)
                ("M-p" . symbol-overlay-jump-prev)))
#+END_SRC

** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :defer t
    :diminish t
    :hook
    (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Subword and super-word modes
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'subword
    (diminish 'subword-mode)
    (diminish 'superword-mode))
#+END_SRC

** Large files

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'so-long-enable)
    (add-hook 'after-init-hook 'so-long-enable))

  ;; Use vlf package for very large files
  (use-package vlf)

  (defun ffap-vlf ()
    "Find file at point with VLF."
    (interactive)
    (let ((file (ffap-file-at-point)))
      (unless (file-exists-p file)
        (error "File does not exist: %s" file))
      (vlf file)))
#+END_SRC

** Emacs backups

Emacs only saves backups on the first save, an not every save. One
could set ~buffer-backed-up~ to ~nil~ on the ~before-save-hook~, to
trigger a backup on each save.

There's also a ~backup-walker~ package that may be useful, if we are
into back-ups a lot. But, currently, almost everything that I work on,
is in ~git~ and it doesn't seem super useful to have so much setup for
backups.

#+BEGIN_SRC emacs-lisp
  ;; New location for backups.
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory))))

  ;; Silently delete execess backup versions
  (setq delete-old-versions t)

  ;; Only keep the last 3 backups of a file.
  (setq kept-old-versions 3)

  ;; Even version controlled files get to be backed up.
  (setq vc-make-backup-files t)

  ;; Use version numbers for backup files.
  (setq version-control t)
#+END_SRC

** Whitespace

Let's start off by cleaning-up any accidental trailing whitespace and
in other places upon save.
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

See [[http://ergoemacs.org/emacs/whitespace-mode.html][here]] for making whitespace visible; including spaces, tabs, and
newlines

** Fill column
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

** Screenshots
Emacs can screenshot itself into an SVG.
Code from https://www.reddit.com/r/emacs/comments/idz35e/comment/g2c2c6y/

#+begin_src emacs-lisp
  (defun pc/screenshot-svg ()
    "Save a screenshot of the current frame as an SVG image.
  Saves to a temp file and puts the filename in the kill ring."
    (interactive)
    (let* ((filename (make-temp-file "Emacs" nil ".svg"))
           (data (x-export-frames nil 'svg)))
      (with-temp-file filename
        (insert data))
      (kill-new filename)
      (message filename)))

#+end_src

* Programming
** magit and git related stuff

For a full tutorial see [[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]].

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)
    ("C-c b" . magit-blame)
    :custom
    ;; Show word diffs for current hunk
    (magit-diff-refine-hunk t)
    (magit-repository-directories `((,pc/code-directory . 3)
                                    ("~" . 0)
                                    ("~/.life-in-plain-text/" . 0)))
    ;; Do not ask about this variable when cloning.
    (magit-clone-set-remote.pushDefault t))
#+END_SRC

*** Git helpers
#+BEGIN_SRC emacs-lisp
  ;; Incremental blame?
  (use-package git-blamed
    :defer t)

  ;; Major mode for editing git configuration files
  (use-package git-modes
    :defer t)

  ;; Highlight diffs
  (use-package diff-hl
    :defer
    :config
    (global-diff-hl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  ;; NOTE: DISABLED because I don't really like the pop-ups, and prefer magit blame!
  ;; M-x git-messenger:popup-message
  (use-package git-messenger
    :custom
    ;; Always show who authored the commit and when.
    (git-messenger:show-detail t)
    ;; Message menu let's us use magit diff to see the commit change.
    (git-messenger:use-magit-popup t))
#+END_SRC

*** Magit helpers
#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :config
    (setq magit-todos-exclude-globs '("*.css.map")))
#+END_SRC

*** GitHub helpers

Get links/browse the file/commit on GitHub.

#+BEGIN_SRC emacs-lisp
  ;; More generic is “browse-at-remote”.
  ;; Not very useful, if we have git-link?
  ;; (use-package github-browse-file :defer t)

  ;; Link to specific parts of a file
  (use-package git-link :defer t)

  ;; Gists from Emacs
  (use-package gist :defer t)

  ;; Turn references to PRs/Issues to clickable links
  ;; PR emacs/2 (Only the number is used -- emacs is ignored)
  ;; Bug 2 also works
  (use-package bug-reference-github
    :hook
    (prog-mode . bug-reference-github-set-url-format))

  (use-package github-review :defer t)

  (use-package forge :after magit)
#+END_SRC

*** For other VCS
I haven't used anything other than ~git~ for a while now, but these
packages seem like useful tools for other kinds of repositories.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package magit-svn
    :hook (magit-mode . magit-svn-mode))

  ;; magit for hg
  (use-package monky)
#+END_SRC

** TODOs highlighting

Global TODOs highlighting

#+BEGIN_SRC emacs-lisp
  ;; NOTE that the highlighting works even in comments.
  (use-package hl-todo
    ;; I want todo-words highlighted in prose, not just in code fragements.
    :hook (org-mode . hl-todo-mode)
    :config
    ;; Enable it everywhere.
    (global-hl-todo-mode))
#+END_SRC

Show TODO keywords in magit status buffer!

#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :after magit
    :after hl-todo
    :config
    (magit-todos-mode))
#+END_SRC

** Project management
*** Setup projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode +1)
    :custom
    (projectile-project-search-path `((,pc/code-directory . 3)))
    (projectile-indexing-method 'alien)
    (projectile-sort-order 'recently-active)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+end_src
*** Install ~ag~
#+begin_src emacs-lisp
  (use-package ag
    :defer t)
#+end_src

** yaml mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

** Flycheck mode
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+end_src
** Javascript
#+begin_src emacs-lisp
  (setq js-indent-level 2)
#+end_src
*** Prettier
#+begin_src emacs-lisp
  (defun pc/enable-minor-mode (my-pair)
    "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
    (if (buffer-file-name)
        (if (string-match (car my-pair) buffer-file-name)
            (funcall (cdr my-pair)))))

  (defun pc/disable-whitespace-cleanup ()
    "Set whitespace-style to nil locally."
    (interactive)
    (setq-local whitespace-style nil))

  (use-package prettier-js
    :defer t
    :config
    (add-hook 'js-mode-hook 'prettier-js-mode)
    (add-hook 'js-mode-hook #'pc/disable-whitespace-cleanup)
    (add-hook 'js-jsx-mode-hook 'prettier-js-mode)
    (add-hook 'js-jsx-mode-hook #'pc/disable-whitespace-cleanup)
    (add-hook 'js2-mode-hook 'prettier-js-mode)
    (add-hook 'js2-mode-hook #'pc/disable-whitespace-cleanup)
    (add-hook 'typescript-mode-hook 'prettier-js-mode)
    (add-hook 'typescript-mode-hook #'pc/disable-whitespace-cleanup)
    (add-hook 'web-mode-hook #'(lambda ()
                                 (pc/enable-minor-mode
                                  '("\\.jsx?\\'" . prettier-js-mode)))))
#+end_src
** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :defer t)
#+end_src
** Python
*** Use anaconda mode for code completion, etc.
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :demand t
    :after python
    :hook ((python-mode . anaconda-mode)
           (python-mode . anaconda-eldoc-mode)))
#+END_SRC
*** Use autoflake to remove unused imports
#+BEGIN_SRC emacs-lisp
  (defun pc/autoflake-remove-unused-imports-before-save ()
    (interactive)
    (when (eq major-mode 'python-mode)
      (if (executable-find "autoflake")
          (progn
            (shell-command (format "autoflake --remove-all-unused-imports -i %s"
                                   (shell-quote-argument (buffer-file-name))))
            (revert-buffer t t t))
        (message "Error: Cannot find autoflake executable."))))

  ;; NOTE: The hook is added after py-isort hook has been added below

#+end_src

*** Use isort to sort imports
#+BEGIN_SRC emacs-lisp
  (defun pc/py-clean-up-imports-hook ()
    "Hooks that clean up python mode imports."
    ;; Hooks are added at the head of the before-save-hook list. So, hooks should
    ;; be added here in the reverse order in which they should be applied.
    (add-hook 'before-save-hook 'py-isort-before-save nil t)
    ;; The function is called on the file, and not buffer. So, we call it after saving the file
    (add-hook 'after-save-hook 'pc/autoflake-remove-unused-imports-before-save nil t))

  (use-package py-isort
    :demand t
    :after python
    :hook (python-mode . pc/py-clean-up-imports-hook))
#+END_SRC

*** Use black in Python buffers
NOTE: This appears after the isort stuff above.. since we want blacken to be
the last thing to run!
#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :demand t
    :after python
    :hook (python-mode . blacken-mode)
    :config
    (setq blacken-line-length 100))

#+END_SRC
*** Use poetry with poetry-tracking-mode
#+BEGIN_SRC emacs-lisp
  (use-package poetry
    :demand t
    :after python
    :hook (python-mode . poetry-tracking-mode))
#+END_SRC
** Emacs Lisp
*** Generate README from file header
#+begin_src emacs-lisp
(use-package md-readme)
#+end_src
*** Package lint for submitting packages to melpa
#+begin_src emacs-lisp
(use-package package-lint)
#+end_src
** Ocaml
#+begin_src emacs-lisp
  ;; Tuareg
  (use-package tuareg)

  (setq pc/ocaml-default-dir "/home/punchagan/.opam/default/")
  (when (file-directory-p pc/ocaml-default-dir)
    (push (expand-file-name "share/emacs/site-lisp" pc/ocaml-default-dir) load-path)

    ;; Merlin
    (setq merlin-command (expand-file-name "bin/ocamlmerlin" pc/ocaml-default-dir))
    (autoload 'merlin-mode "merlin" "Merlin mode" t)
    (add-hook 'tuareg-mode-hook #'merlin-mode)
    (add-hook 'caml-mode-hook #'merlin-mode)

    ;; Ocamlformat
    (require 'ocamlformat)
    (add-hook 'tuareg-mode-hook
              (lambda ()
                (define-key tuareg-mode-map (kbd "C-M-<tab>") #'ocamlformat)
                (add-hook 'before-save-hook #'ocamlformat-before-save)))
    )
#+end_src
** Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :defer t)
#+end_src
** GitHub Co-Pilot
#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq pc/copilot-load-path
          (expand-file-name "misc/copilot.el/" pc/code-directory)))
  (use-package editorconfig
    :ensure t)
  (use-package copilot
    :load-path pc/copilot-load-path
    :demand
    :init
    (setq copilot-idle-delay 0.5)
    ;; Turn on Copilot in prog mode
    (add-hook 'prog-mode-hook 'copilot-mode)
    :bind (:map copilot-mode-map
           ("C-c C-c" . copilot-accept-completion)))
#+END_SRC
** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+end_src
* Prose and Literate Programming
** Org mode
Some basic org-mode configuration

#+BEGIN_SRC emacs-lisp
  (use-package org
    :pin gnu
    :ensure t
    :defer t
    :bind (("C-c c" . org-capture)
           (:map org-mode-map
                 ("C-c C-q" . counsel-org-tag))))

  (setq org-directory "~/.life-in-plain-text/src/")
  (setq org-return-follows-link t)
#+END_SRC
*** Paste HTML as org text

Adapted from this [[https://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][stackexchange]] post. There are also suggestions to use
~org-web-tools-read-url-as-org~. May be worth exploring

#+begin_src emacs-lisp
  (defun pc/html2org-clipboard ()
    "Convert clipboard contents from HTML to Org and then paste (yank)."
    (interactive)
    (kill-new (shell-command-to-string "xclip -o -t text/html | pandoc -f html -t org"))
    (yank))
#+end_src
** Table of contents
#+begin_src emacs-lisp
  (use-package org-make-toc
    :ensure t
    :defer t)
#+end_src

** Org tags
#+BEGIN_SRC emacs-lisp
  (setq org-complete-tags-always-offer-all-agenda-tags t)
#+END_SRC

** Org Agenda and TODOs et al
*** Basic config
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (expand-file-name "agenda-files.org" org-directory))

  ;; Enable a bunch of things, since we are going to use them, anyway..
  (require 'org-clock)
  (require 'org-agenda)
  (require 'org-capture)

  (setq org-enforce-todo-dependencies t)

  ;; Add a note whenever a task's deadline or scheduled date is changed.
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)

  ;; How many days early a deadline item will begin showing up in your agenda list.
  (setq org-deadline-warning-days 7)

  ;; In the agenda view, days that have no associated tasks will still have a line showing the date.
  (setq org-agenda-show-all-dates t)

  ;; Scheduled items marked as complete will not show up in your agenda view.
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
#+END_SRC
*** Super agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :defer t)

  (use-package org-ql
      :defer t)

  ;; FIXME: Add some filters and stuff to make it more useful?
#+END_SRC
*** What are you doing?
**** Template to capture journal entries
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-capture-templates
               '("j"
                 "Journal"
                 entry
                 (file+olp+datetree "journal.org")
                 "* %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n%a\n"))
#+END_SRC
**** Custom code to fire off journal mode

#+BEGIN_SRC emacs-lisp
  (defun pc/journal (&optional mode)
    "Open a new frame for journaling.

  If MODE is 'journal opens to the current day in the journal, and
  creates a new day entry if not already present.

  If MODE is 'clock jumps to the currently clocked entry, or prompt
  one from the last few."
    (interactive)
    (pc/select-window-by-name "What are you doing?")
    ;; Display agenda...
    (org-agenda nil "a")
    (org-super-agenda-mode t)
    (org-agenda-log-mode t)
    (org-agenda-day-view)
    (org-agenda-goto-today)
    (delete-other-windows)
    (split-window-right)
    ;; Perform next action based on mode
    (cond
     ;; Show a capture buffer for a new journal entry
     ((equal mode 'journal)
      (org-capture nil "j"))
     ;; Show the current clock entry, if there's one. Otherwise prompt!
     ((equal mode 'clock)
      (org-clock-goto (not (org-clocking-p)))
      (org-narrow-to-subtree)
      (outline-show-subtree)
      (goto-char (buffer-end 1)))
     ;; Show today in the journal
     (t
      (org-capture-goto-target "j")
      (org-narrow-to-subtree))))

  (defun pc/get-frame-by-name (title)
    "Return frame with the given TITLE.
  If no such frame exists, creates a new frame."
    (or
     (car (filtered-frame-list
           (lambda (f)
             (string= title (cdr (assq 'title (frame-parameters f)))))))
     (make-frame
      `((title . ,title)
        (fullscreen . maximized)))))

  (defun pc/select-window-by-name (title)
    "Raise the window with the specified TITLE."
    (let ((frame (pc/get-frame-by-name title)))
      (select-frame frame)
      (shell-command (format "wmctrl -R \"%s\"" title))))
#+END_SRC
**** Work Today
Quickly create a summary of headlines tagged with specific tag


#+BEGIN_SRC emacs-lisp
  (defun pc/work-today ()
    "Create a journal entry with today's work tasks"
    (interactive)
    (let* ((date (format-time-string "%Y-%m-%d"))
           (title "Notes for Today")
           (org-last-tags-completion-table
            (org-global-tags-completion-table
             (org-agenda-files)))
           (tags
            (org-completing-read "Tags:" #'org-tags-completion-function))
           (headlines (org-ql-query
                        :select '(org-get-heading t t t t)
                        :from (org-agenda-files)
                        :where `(and (clocked :on ,date) (tags tags)))))

      ;; Exit early if no matching headlines
      (when (not headlines)
        (user-error "No matching headlines"))

      (when (org-clocking-p)
        (org-clock-out))
      (pc/journal)
      (end-of-buffer)
      (org-insert-heading-after-current)
      (insert title)
      (org-set-tags tags)
      (end-of-buffer)
      (mapc (lambda (item) (insert (format "- %s\n" (org-no-properties item)))) headlines)))

#+END_SRC

** Org mode and Zulip
#+BEGIN_SRC emacs-lisp
  (use-package request :defer t)
  (use-package ox-gfm :defer t)

  (eval-and-compile
    (setq zulip-helpers-load-path
          (expand-file-name "my-repos/zulip-helpers.el" pc/code-directory)))

  (use-package zulip-helpers
      :load-path zulip-helpers-load-path)
#+END_SRC

*** Convert markdown from Zulip (or Slack or GitHub) to org
#+begin_src emacs-lisp
  (defun pc/zulip-to-org (begin end)
    (interactive "r")
    (when (use-region-p)
      (shell-command-on-region begin end "pandoc -r markdown -w org" t t)))
#+end_src
** Org capture
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC
*** Template to capture protocol entries
#+BEGIN_SRC emacs-lisp
  (add-to-list
     'org-capture-templates
     '("p"
       "Protocol"
       entry
       (file+olp+datetree "journal.org")
       "* %:description\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n%:link\n\n#+begin_quote\n%i\n#+end_quote\n"))
#+END_SRC
** Org babel
Template expansion!
#+begin_src emacs-lisp
  (require 'org-tempo)
#+end_src
*** Enable org-babel for some languages
#+begin_src emacs-lisp
  (setq org-babel-load-languages '((emacs-lisp . t)
                                   (python . t)
                                   (sh . t)))

  (require 'ob-emacs-lisp)
  (require 'ob-python)
#+end_src
** Org reveal
#+begin_src emacs-lisp
  (use-package ox-reveal :ensure t)
#+end_src
** Org subtree to gist
#+begin_src emacs-lisp
  (eval-and-compile
    (setq ox-gist-load-path
          (expand-file-name "my-repos/ox-gist" pc/code-directory)))

  (use-package ox-gist
    :load-path ox-gist-load-path)
#+end_src
** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode :defer t)
#+END_SRC
*** Markdown toc
#+BEGIN_SRC emacs-lisp
  (use-package markdown-toc :defer t)
#+END_SRC
** Hugo & Blog setup
#+begin_src emacs-lisp
  ;; Copied from newer org-mode since ox-hugo needs it

  (defun org-back-to-heading-or-point-min (&optional invisible-ok)
    "Go back to heading or first point in buffer.
  If point is before first heading go to first point in buffer
  instead of back to heading."
    (condition-case nil
        (outline-back-to-heading invisible-ok)
      (error
       (goto-char (point-min)))))
#+end_src
#+begin_src emacs-lisp
  (use-package ox-hugo
    :ensure t            ;Auto-install the package from Melpa (optional)
    :after ox)
#+end_src

#+begin_src emacs-lisp
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post."
    (let* ((date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time)))
           (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title " :noexport:")
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                   ":EXPORT_DESCRIPTION:"
                   ":EXPORT_HUGO_CUSTOM_FRONT_MATTER:"
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("b"
                 "Blog post for punchagan.muse-amuse.in"
                 entry
                 (file "blog-posts.org")
                 (function org-hugo-new-subtree-post-capture-template)
                 :prepend t))
#+end_src
** Inbox.org (Orgzly) refile
*** Refile single subtree
#+begin_src emacs-lisp
  (defun pc/org-refile-subtree-to-journal ()
    "Refile a subtree to a journal.org datetree corresponding to it's timestamp."
    (interactive)
    (let* ((entry-date (org-entry-get nil "CREATED" t))
           (org-overriding-default-time
            (apply #'encode-time (org-parse-time-string entry-date)))
           (buf (current-buffer)))
      (when entry-date
        (org-cut-subtree)
        ;; Set the continuation position when this function is called from org-map-entries
        (setq org-map-continue-from (point))
        (save-mark-and-excursion
          (org-capture-goto-target "j")
          (org-narrow-to-subtree)
          (org-show-subtree)
          (org-end-of-subtree t)
          (newline)
          (goto-char (point-max))
          (org-paste-subtree 4)
          (widen)
          (save-buffer)
          (switch-to-buffer buf)
          (save-buffer)))))
#+end_src
*** Refile Inbox.org

Refile all the entries in Inbox.org

#+begin_src emacs-lisp
  (defun pc/org-refile-inbox ()
    (interactive)
    (require 'dash)
    (require 's)
    (org-map-entries
     #'pc/org-refile-subtree-to-journal
     nil
     (-filter (lambda (x) (s-contains? "Inbox.org" x)) (org-agenda-files))))
#+end_src
** Reading PDFs and taking notes
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t)
  ;; Install pdf loader
  (pdf-loader-install)
#+end_src

Install Org noter

#+begin_src emacs-lisp
  (use-package org-noter
    :ensure t)
#+end_src
** Org crypt
#+begin_src emacs-lisp
  (require 'org-crypt)
#+end_src
** Org bookmarks
#+begin_src emacs-lisp
  (use-package org-bookmark-heading
    :defer t)
#+end_src
* Using Emacs from the "outside"
** Emacs Anywhere
Add the ability to use Emacs from input area.

We need to manually configure a keybinding to run
=~/.emacs_anywhere/bin/run=.

#+BEGIN_SRC text :tangle fake-lisp/README.md :results none :comments none
  This directory contains fake packages that we create to be able to use
  the `use-package` and it's wonderful `:ensure-system-package`
  functionality.
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle fake-lisp/emacs-anywhere.el :comments link :results none
  ;; This is a fake package created by us to try to ensure system packages
  (provide 'emacs-anywhere)
  ;;; emacs-anywhere ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun pc/github-conversation-p (window-title)
    (or (string-match-p "Pull Request #" window-title)
        (string-match-p "Issue #" window-title)))

  (defun pc/ea-popup-handler (app-name window-title x y w h)
    ;; set major mode
    (cond
     ;; ((pc/github-conversation-p window-title) (gfm-mode))
     ;; default major mode
     (t (org-mode))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package emacs-anywhere
    :defer 5
    :load-path "fake-lisp"

    :ensure-system-package
    ((xclip . xclip)
     (xdotool . xdotool)
     (xwininfo . xwininfo)
     ;; NOTE: The script itself checks for deps, and installing deps
     ;; asynchronously may cause the script to fail. Reloading the
     ;; requirement after other system deps are installed makes it work.
     ("~/.emacs_anywhere/bin/run" . "curl-bash-install https://raw.github.com/zachcurry/emacs-anywhere/master/install"))

    :config
    (add-hook 'ea-popup-hook 'pc/ea-popup-handler))
#+END_SRC

* COMMENT Local Variables
# Local Variables:
# eval: (add-hook 'after-save-hook 'pc/tangle-init-el nil 'local-to-this-file-please)
# End:
