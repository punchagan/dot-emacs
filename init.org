#+STARTUP: indent
#+TITLE: A literate Emacs configuration
#+DESCRIPTION: This file contains my Emacs init.el configuration as a literate program, which is generated by tangling this document.
#+PROPERTY: header-args :tangle init.el :comments link :results none

* Basic setup for init
** Lexical binding
We set the heading line of the file, to enable lexical
binding. This makes it easier to define variables to use in hooks
that are run later, etc. See [[gc-thresholds][gc-threshold src block]] for example.

#+BEGIN_SRC emacs-lisp :comments none
  ;;; init.el --- Load the full configuration -*- lexical-binding: t -*-
#+END_SRC

** Enable debug if required
Produce backtraces when errors occur: can be helpful to diagnose startup issues
#+BEGIN_SRC emacs-lisp
  ;; (setq debug-on-error t)
#+END_SRC

** Check that Emacs is not too old
#+BEGIN_SRC emacs-lisp
  (let ((minver "25.1"))
    (when (version< emacs-version minver)
      (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

  (when (version< emacs-version "26.1")
    (message "Your Emacs is old, and some functionality in this config will be disabled. Please upgrade if possible."))
#+END_SRC

** Adjust garbage collection thresholds
Allow for a much higher garbage collection threshold during startup,
to prevent gc from slowing down startup.

#+name: gc-thresholds
#+BEGIN_SRC emacs-lisp
  (let ((normal-gc-cons-threshold (* 20 1024 1024))
        (init-gc-cons-threshold (* 128 1024 1024)))
    (setq gc-cons-threshold init-gc-cons-threshold)
    (add-hook 'emacs-startup-hook
              (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))
#+END_SRC

** ~init.el~ file generation
:PROPERTIES:
:CUSTOM_ID: my-make-init-el-function
:END:

We genarate the ~init.el~ file, whenever this file gets saved. We need
to save with a prefix argument, though. ~C-u C-x C-s~.

#+name: startup-code
#+BEGIN_SRC emacs-lisp
  (defun pc/tangle-init-el ()
    "Tangle the file to update init.el file."
    (interactive "P")
    (let* ((time (current-time)))
      (when current-prefix-arg
        ;; Make and load init.el
        (org-babel-tangle)
        ;; Acknowledgement
        (message
         "Tangled  init.el … %.06f seconds."
         (float-time (time-since time))))))

  (defun pc/load-init-el ()
    "Load the init.el file."
    (interactive)
    (let* ((time (current-time))
           (init-file (expand-file-name
                       "init.el"
                       (file-name-directory (buffer-file-name)))))

        ;; Make and load init.el
        (org-babel-tangle)
        ;; NOTE: Loading the init file doesn't work well...
        ;; We just tangle the file on save, and leave it at that. This
        ;; utility is left around, in case we occasionally chosee to
        ;; load the file manually. Ideally, when we are happy with the
        ;; config, we should just start a new Emacs instance.
        (setq pc/loading-tangled-init-p t)
        (load-file init-file)

        ;; Acknowledgement
        (message
         "Tangled, compiled, and loaded init.el … %.06f seconds. Restart Emacs if things get weird..."
         (float-time (time-since time)))))

  ;; Added this as a local variable in the org file
  ;; (add-hook 'after-save-hook 'org-babel-tangle nil 'local-to-this-file-please)
#+END_SRC
** Basic user information
#+begin_src emacs-lisp
  (setq user-full-name    "Puneeth Chaganti"
        user-mail-address "punchagan@muse-amuse.in")
#+end_src

For some fun, run this cute method.
#+BEGIN_SRC emacs-lisp :tangle no
  (animate-birthday-present user-full-name)
#+END_SRC
* Package manager and installation
** Setup ~package.el~
#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives '(("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.org/packages/")))

  ;; Update local list of available packages. We don't want to do this
  ;; on start-up, right?
  ;; (package-refresh-contents)

  ;; Ensure the installed packages are on load-path
  (package-initialize)
#+END_SRC
** Setup ~use-package~

The declarative configuration tool [[https://github.com/jwiegley/use-package/][use-package]] is a macro/interface
that manages our packages and the way they interact.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; ~use-package.el~ is no longer needed at runtime
  ;; Put the following at the top of your Emacs, to reduce load time:
  (eval-when-compile
    (require 'use-package))

  (require 'diminish)
  (require 'bind-key)
#+END_SRC

To make the setup bootstrap itself, we use let ~use-package~
automatically download missing requirements.
 
#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src
** Auto update package
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :config
    ;; Delete residual old versions
    (setq auto-package-update-delete-old-versions t)
    ;; Do not bother me when updates have taken place.
    (setq auto-package-update-hide-results t)
    ;; Update installed packages at startup if there is an update pending.
    (auto-package-update-maybe))
#+END_SRC
** System packages used from with-in Emacs
 
Sometimes Emacs packages depend on existing system binaries,
~use-package~ let's us ensure these exist using the
~:ensure-system-package~ keyword extension. This is a very powerful
system - see the documentation [[https://github.com/jwiegley/use-package#use-package-ensure-system-package][here]].

This is like ~:ensure t~ but operates at the OS level and uses your
default OS package manager. But, it can be customized to run specific
commands for update, etc.

We also run an auto-update for system packages, after an update for
Emacs packages is done ^_^.

#+BEGIN_SRC emacs-lisp
  ;; Auto installing OS system packages
  (use-package use-package-ensure-system-package
    :defer 4

    :config
    (setq system-packages-package-manager 'apt
          system-packages-use-sudo t)
    (unless (boundp 'pc/loading-tangled-init-p)
      (system-packages-update)))

  ;; Please don't bother me when shell buffer names are in use, just make a new
  ;; buffer.
  (setq async-shell-command-buffer 'new-buffer)

  ;; Display the output buffer for asynchronous shell commands only when the
  ;; command generates output.
  (setq async-shell-command-display-buffer nil)

  ;; Don't ask me if I want to kill a buffer with a live process attached to it;
  ;; just kill it please.
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

* $PATH and such stuff
** Setup exec-path 
To be able to find external programs, we want our ~exec-path~ to be as
close to ~$PATH~ as possible.

NOTE: When starting emacs from Gnome Shell, the env vars in
bash_profile are not in the env anyway? May be there's another trick,
or may be don't start emacs from Gnome Shell?

The block below is left here, because it seems to copy other useful
things like LANG, etc.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell

    :config
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
      (add-to-list 'exec-path-from-shell-variables var))

    (when (or (memq window-system '(mac ns x))
              (unless (memq system-type '(ms-dos windows-nt))
                (daemonp)))
      (exec-path-from-shell-initialize)))
#+END_SRC
** Use authinfo gpg file
#+BEGIN_SRC emacs-lisp
  (setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
** Start Emacs server
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

* Editor UI & Behavior
* Random Quote
Show a random quote when Emacs is idle for 5 minutes
#+BEGIN_SRC emacs-lisp
  (require 'json)

  (defun pc/get-random-quote ()
    (let* ((json-array-type 'list)
           (quotes-file "quotes.json")
           (quotes (and (file-exists-p quotes-file)
                        (json-read-file quotes-file)))
           (n (random (length quotes)))
           (q (nth n quotes))
           (text (cdr (assoc 'body q)))
           (source (cdr (assoc 'source q))))
      (format "%s -- %s" text source)))

  (unless (boundp 'pc/quotes-timer)
    (setq pc/quotes-timer
          (run-with-idle-timer
           300
           'repeat-forever
           (lambda () (message (pc/get-random-quote))))))
#+END_SRC
** Lean UI
#+BEGIN_SRC emacs-lisp
  ;; No startup message
  (setq inhibit-startup-message t)

  (setq-default
   initial-scratch-message
   (format ";; Happy hacking, %s - Emacs ♥ you!\n\n" user-login-name))

  ;; No tool-bar, menu-bar and scroll-bar
  (tool-bar-mode   -1)
  (menu-bar-mode   -1)
  (scroll-bar-mode -1)

  ;; More prominent window divider
  (window-divider-mode 1)
#+END_SRC
** Basic Preferences

Miscellaneous basic preferences for basic editor actions (foreground &
background).

#+BEGIN_SRC emacs-lisp
  ;; Basic preferences (taken from purcell)
  (setq-default
   blink-cursor-interval 0.4
   bookmark-default-file (expand-file-name ".bookmarks.el" user-emacs-directory)
   buffers-menu-max-size 30
   case-fold-search t
   column-number-mode t
   confirm-kill-emacs (lambda (t) (y-or-n-p (format "%s\n%s" (pc/get-random-quote) t)))
   indent-tabs-mode nil
   create-lockfiles nil
   auto-save-default nil
   mouse-yank-at-point t
   save-interprogram-paste-before-kill t
   scroll-preserve-screen-position 'always
   set-mark-command-repeat-pop t
   tooltip-delay 1.5
   truncate-lines nil
   truncate-partial-width-windows nil)
#+END_SRC

Some more basic preferences which are called in the ~after-init-hook~.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'delete-selection-mode)

  (add-hook 'after-init-hook 'global-auto-revert-mode)
  (setq global-auto-revert-non-file-buffers t
        auto-revert-verbose nil)
  (with-eval-after-load 'autorevert
    (diminish 'auto-revert-mode))

  (add-hook 'after-init-hook 'transient-mark-mode)
#+END_SRC

Let's save a few precious seconds

#+begin_src emacs-lisp
;; change all prompts to y or n
(fset 'yes-or-no-p 'y-or-n-p)

;; Enable all ‘possibly confusing commands’ such as helpful but
;; initially-worrisome “narrow-to-region”, C-x n n.
(setq-default disabled-command-function nil)
#+end_src

** Fill column indicator
#+BEGIN_SRC emacs-lisp
  (when (boundp 'display-fill-column-indicator)
    (setq-default indicate-buffer-boundaries 'left)
    (setq-default display-fill-column-indicator-character ?│)
    (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode))
#+END_SRC

** ~diminish~ for modeline indicators

This should probably have automatically come as a dependency of
~use-package~, but doesn't seem to be. (It should at least warn about
missing package)

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :defer 3 ;; load after 5 seconds of idle time

    :config ;; Let's hide some markers.
    (diminish 'org-indent-mode))
#+END_SRC
** Use ~which-key~ for discovery
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config (which-key-mode)
    (which-key-setup-side-window-bottom)
    (setq which-key-idle-delay 0.5))
#+END_SRC
** Restore previous session
The following is disabled. I found it a nuisance to have my files open
across sessions. If I'm closing Emacs, it's for a good reason.

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Keep open files open across sessions.
  (desktop-save-mode 1)
  (setq desktop-restore-eager 10)
#+END_SRC
** Completion and Narrowing

See this [[https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html][blog post]] for more configuration options, and other packages
to install, etc.

Hit ~M-o~ to see the available actions in ivy/counsel completion
buffers! For instance, ~counsel-find-file~ allows copying, deleting or
renaming files!

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :diminish
    :ensure-system-package (ag . silversearcher-ag)
    :bind*                              ; load when pressed
    (("C-s"     . swiper)
     ("C-S-s" . counsel-ag)               ; Use ag to search the repo
     ("<f1> l"  . counsel-find-library)   ; find an Emacs Lisp library
     ("<f2> u"  . counsel-unicode-char))  ; insert a unicode symbol using a pop-up
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish
    :config
    ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; Number of lines to display
    (setq ivy-height 10)
    (setq ivy-count-format "[%d/%d] ")
    ;; no initial regexp by default (see original value using
    ;; `describe-variable')
    (setq ivy-initial-inputs-alist nil)
    (ivy-mode 1)
    (counsel-mode 1))
#+END_SRC

~swiper~ is an alternative to Emacs' default incremental search.
** Themes

#+BEGIN_SRC emacs-lisp
  ;; Don't prompt to confirm theme safety. This avoids problems with
  ;; first-time startup on Emacs > 26.3.
  (setq custom-safe-themes t)
#+END_SRC
*** Some code to pick and load a theme

#+BEGIN_SRC emacs-lisp
  (defun pc/load-theme (theme)
    "Apply user theme."
    (interactive
     (list
      (intern (ivy-read "Load custom theme: "
                        (mapcar #'symbol-name
                                (custom-available-themes))))))
    (progn
      ;; Disable all previously enabled themes
      (mapc 'disable-theme custom-enabled-themes)
      ;; Load chosen theme
      (load-theme theme)))
#+END_SRC

*** Ensure some nice themes are available
#+BEGIN_SRC emacs-lisp
  (use-package base16-theme)
  (unless (boundp 'pc/loading-tangled-init-p)
    (pc/load-theme 'base16-humanoid-dark))
#+END_SRC
** Symbol overlays
#+BEGIN_SRC emacs-lisp
  (use-package symbol-overlay
    :defer t
    :diminish t
    :hook
    (prog-mode . symbol-overlay-mode)
    (html-mode . symbol-overlay-mode)
    (yaml-mode . symbol-overlay-mode)
    (conf-mode . symbol-overlay-mode)
    :bind (:map symbol-overlay-mode-map
                ("M-i" . symbol-overlay-put)
                ("M-I" . symbol-overlay-remove-all)
                ("M-n" . symbol-overlay-jump-next)
                ("M-p" . symbol-overlay-jump-prev)))
#+END_SRC

** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :defer t
    :diminish t
    :hook
    (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Subword and super-word modes
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'subword
    (diminish 'subword-mode)
    (diminish 'superword-mode))
#+END_SRC

** Large files

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'so-long-enable)
    (add-hook 'after-init-hook 'so-long-enable))

  ;; Use vlf package for very large files
  (use-package vlf)

  (defun ffap-vlf ()
    "Find file at point with VLF."
    (interactive)
    (let ((file (ffap-file-at-point)))
      (unless (file-exists-p file)
        (error "File does not exist: %s" file))
      (vlf file)))
#+END_SRC

** Emacs backups

Emacs only saves backups on the first save, an not every save. One
could set ~buffer-backed-up~ to ~nil~ on the ~before-save-hook~, to
trigger a backup on each save.

There's also a ~backup-walker~ package that may be useful, if we are
into back-ups a lot. But, currently, almost everything that I work on,
is in ~git~ and it doesn't seem super useful to have so much setup for
backups.

#+BEGIN_SRC emacs-lisp
  ;; New location for backups.
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory))))

  ;; Silently delete execess backup versions
  (setq delete-old-versions t)

  ;; Only keep the last 3 backups of a file.
  (setq kept-old-versions 3)

  ;; Even version controlled files get to be backed up.
  (setq vc-make-backup-files t)

  ;; Use version numbers for backup files.
  (setq version-control t)
#+END_SRC

* Programming
** magit and git related stuff

For a full tutorial see [[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]].

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)
    ("C-c b" . magit-blame)
    :custom
    ;; Show word diffs for current hunk
    (magit-diff-refine-hunk t)
    ;; Do not ask about this variable when cloning.
    (magit-clone-set-remote.pushDefault t))
#+END_SRC

# FIXME: Set ~magit-repository-directories~, or projectile directories
# to quickly open projects.

*** Git helpers
#+BEGIN_SRC emacs-lisp
  ;; Incremental blame?
  (use-package git-blamed
    :defer t)

  ;; Major mode to edit git ignore files
  (use-package gitignore-mode
    :defer t)

  ;; Major mode to edit git config files
  (use-package gitconfig-mode
    :defer t)

  ;; Highlight diffs
  (use-package diff-hl
    :defer
    :config
    (global-diff-hl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  ;; NOTE: DISABLED because I don't really like the pop-ups, and prefer magit blame!
  ;; M-x git-messenger:popup-message
  (use-package git-messenger
    :custom
    ;; Always show who authored the commit and when.
    (git-messenger:show-detail t)
    ;; Message menu let's us use magit diff to see the commit change.
    (git-messenger:use-magit-popup t))
#+END_SRC

*** Magit helpers
#+BEGIN_SRC emacs-lisp
  (use-package magit-todos)
#+END_SRC

*** GitHub helpers

Get links/browse the file/commit on GitHub.

#+BEGIN_SRC emacs-lisp
  ;; More generic is “browse-at-remote”.
  ;; Not very useful, if we have git-link?
  ;; (use-package github-browse-file :defer t)

  ;; Link to specific parts of a file
  (use-package git-link :defer t)

  ;; Gists from Emacs
  (use-package yagist :defer t)

  ;; Turn references to PRs/Issues to clickable links
  ;; PR emacs/2 (Only the number is used -- emacs is ignored)
  ;; Bug 2 also works
  (use-package bug-reference-github
    :hook
    (prog-mode . bug-reference-github-set-url-format))

  (use-package github-review :defer t)

  (use-package forge :after magit)
#+END_SRC

*** For other VCS
I haven't used anything other than ~git~ for a while now, but these
packages seem like useful tools for other kinds of repositories.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package magit-svn
    :hook (magit-mode . magit-svn-mode))

  ;; magit for hg
  (use-package monky)
#+END_SRC

** TODOs highlighting

Global TODOs highlighting

#+BEGIN_SRC emacs-lisp
  ;; NOTE that the highlighting works even in comments.
  (use-package hl-todo
    ;; I want todo-words highlighted in prose, not just in code fragements.
    :hook (org-mode . hl-todo-mode)
    :config
    ;; Enable it everywhere.
    (global-hl-todo-mode))
#+END_SRC

Show TODO keywords in magit status buffer!

#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :after magit
    :after hl-todo
    :config
    (magit-todos-mode))
#+END_SRC

* Prose and Literate Programming
** Org Agenda
*** Basic config
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/.life-in-plain-text/src/")
  (setq org-agenda-files
        (expand-file-name "agenda-files.org" org-directory))

  ;; Enable a bunch of things, since we are going to use them, anyway..
  (require 'org-clock)
  (require 'org-agenda)
  (require 'org-capture)
#+END_SRC
*** Super agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :defer t)

  (use-package org-ql
      :defer t)

  ;; FIXME: Add some filters and stuff to make it more useful?
#+END_SRC
*** What are you doing?
**** Template to capture entries
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-capture-templates
               '("j"
                 "Journal"
                 entry
                 (file+olp+datetree "journal.org")
                 "* %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n%a\n"))
#+END_SRC
**** Custom code to fire off journal mode

Simple function to insert the template at the correct location, and
display it with the drawers hidden. We could simply use the capture
template instead of this magic, but this gives us a better UI to be
able to just go ahead and type what we want, instead of being in a
"capture" mode.

#+BEGIN_SRC emacs-lisp
  (defun pc/insert-journal-template ()
    (org-capture nil "j")
    (org-capture-finalize)
    (org-capture-goto-last-stored)
    (org-cycle-hide-drawers 'all)
    (org-end-of-line))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun pc/journal ()
    "Open a new frame for journaling.
      - Jumps to the currently clocked item, if there is one.

      - Otherwise, opens to the current day in the journal, and creates
        a new day entry if not already present."
    (interactive)
    (let* ((title "What are you doing?")
           (frame (or
                   (car (filtered-frame-list
                         (lambda (f)
                           (string= title (cdr (assq 'title (frame-parameters f)))))))
                   (make-frame
                    `((title . ,title)
                      (fullscreen . maximized))))))
      (select-frame frame)
      (org-agenda nil "a")
      (org-super-agenda-mode t)
      (org-agenda-log-mode t)
      (org-agenda-day-view)
      (org-agenda-goto-today)
      (delete-other-windows)
      (split-window-right)
      (if (org-clocking-p)
          (org-clock-goto)
        (pc/insert-journal-template))
      (org-narrow-to-subtree)
      (outline-show-subtree)
      (when (org-clocking-p)
        (goto-char (buffer-end 1)))
      (shell-command (format "wmctrl -a \"%s\"" title))))
#+END_SRC
* Using Emacs from the "outside"
** Emacs Anywhere 
Add the ability to use Emacs from input area. 

We need to manually configure a keybinding to run
=~/.emacs_anywhere/bin/run=.

#+BEGIN_SRC text :tangle fake-lisp/README.md :results none :comments none
  This directory contains fake packages that we create to be able to use
  the `use-package` and it's wonderful `:ensure-system-package`
  functionality.
#+END_SRC 

#+BEGIN_SRC emacs-lisp :tangle fake-lisp/emacs-anywhere.el :comments link :results none
  ;; This is a fake package created by us to try to ensure system packages
  (provide 'emacs-anywhere)
  ;;; emacs-anywhere ends here
#+END_SRC 

#+BEGIN_SRC emacs-lisp
  (defun pc/github-conversation-p (window-title)
    (or (string-match-p "Pull Request #" window-title)
        (string-match-p "Issue #" window-title)))

  (defun pc/ea-popup-handler (app-name window-title x y w h)
    ;; set major mode
    (cond
     ;; ((pc/github-conversation-p window-title) (gfm-mode))
     ;; default major mode
     (t (org-mode))))
#+END_SRC 

#+BEGIN_SRC emacs-lisp
  (use-package emacs-anywhere
    :defer 5
    :load-path "fake-lisp"

    :ensure-system-package
    ((xclip . xclip)
     (xdotool . xdotool)
     (xwininfo . xwininfo)
     ;; NOTE: The script itself checks for deps, and installing deps
     ;; asynchronously may cause the script to fail. Reloading the
     ;; requirement after other system deps are installed makes it work.
     ("~/.emacs_anywhere/bin/run" . "curl-bash-install https://raw.github.com/zachcurry/emacs-anywhere/master/install"))

    :config
    (add-hook 'ea-popup-hook 'pc/ea-popup-handler))
#+END_SRC

* COMMENT Local Variables
# Local Variables:
# eval: (add-hook 'after-save-hook 'pc/tangle-init-el nil 'local-to-this-file-please)
# End:
 
